/*******************************************************************************
 * Copyright (c) 2022 CEA
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 * Contributors: see AUTHORS file
 *******************************************************************************/
grammar fr.cea.modane.Modane with org.eclipse.xtext.common.Terminals

generate modane "http://www.cea.fr/modane/Modane"

// ----------------------------------------------------------------------------------------------------------------- //

ModaneModel:
	description=Comment?
	'package' name=QualifiedName ';'
	elements += ModaneElement*;

NamedElement:
	ModaneElement | Pty | EntryPoint | Function | UnitTestFunction | Arg | EnumerationLiteral;

Referenceable:
	Struct | Interface | Enumeration | Legacy;

ModaneElement:
	Variable | ServiceOrModule | Referenceable | ItemFamily | UserCategory;

QualifiedName:
	ID ('.' ID)*;

// ----------------------------------------------------------------------------------------------------------------- //

Variable:
	description=Comment?
	'var' type=SimpleType name=ID '{' (supports+=Item (',' supports+=Item)?)? '}'
	'@axlname' '('axlName=STRING')' dump?=DUMP? restore?=RESTORE? executionDepend?=EXEC_DEP? needSync?=SYNC?
	('family' family=[ItemFamily|QualifiedName])? ';';

// ----------------------------------------------------------------------------------------------------------------- //

Enumeration:
	description=Comment?
	'enum' name=ID '{' literals+=EnumerationLiteral* '}';

EnumerationLiteral:
	description=Comment?
	('namefr' namefr=STRING)? ('categories' categories+=[UserCategory|QualifiedName] (',' categories+=[UserCategory|QualifiedName])* )?
	name=ID (valueProvided?='=' value=INT)?';';

// ----------------------------------------------------------------------------------------------------------------- //

Legacy:
	description=Comment?
	'legacy' name=ID 'file' originFile=STRING ('namespace' originNamespace=STRING)?';';

// ----------------------------------------------------------------------------------------------------------------- //

Struct:
	description=Comment?
	'struct' name=ID ('extends' parents+=[Struct|QualifiedName] (',' parents+=[Struct|QualifiedName])* )?
	'{' 
		properties+=Pty* 
	'}';

Pty:
	description=Comment?
	multiplicity=PtyMultiplicity type=PtyOrArgType name=ID ('=' defaultValue=STRING)?
	('namefr' namefr=STRING)? ('categories' categories+=[UserCategory|QualifiedName] (',' categories+=[UserCategory|QualifiedName])* )? ';';

PtyOrArgType:
	Simple | Item | ItemGroup | Reference;

// ----------------------------------------------------------------------------------------------------------------- //

Interface:
	description=Comment?
	'interface' name=ID ('extends' parents+=[Interface|QualifiedName] (',' parents+=[Interface|QualifiedName])* )?
	'{'
		properties+=Pty*
		functions+=Function*
	'}';

Function:
	description=Comment?
	'def' (const?='const')?
	('void'|(type=PtyOrArgType (multiple?='*')?))  name=ID
	'(' (args+=Arg (',' args+=Arg)*)? ')'
	 ('on' support=FunctionItem)? (sequential?='sequentially')?
	 ('in' inVars+=VarReference (',' inVars+=VarReference)*)?
	 ('out' outVars+=VarReference (',' outVars+=VarReference)*)?
	 ('inout' inOutVars+=VarReference (',' inOutVars+=VarReference)*)?
	 ('call' calls+=[Function|QualifiedName] (',' calls+=[Function|QualifiedName])* )? ';';

Arg:
	ArgDefinition | VarDefinition;

ArgDefinition:
	direction=Direction type=PtyOrArgType (multiple?='*')? name=ID ('=' defaultValue=STRING)?;

VarDefinition:
	direction=Direction type=SimpleType name=ID '{' (supports+=Item (',' supports+=Item)?)? '}';

VarReference:
	variable=[Variable|QualifiedName];

// ----------------------------------------------------------------------------------------------------------------- //

ItemFamily:
	description=Comment?
	'ItemFamily' name=ID
	'on' support=ItemType ';';

// ----------------------------------------------------------------------------------------------------------------- //

ServiceOrModule:
	Service | Module;

Service:
	description=Comment?
	'service' type=ServiceType singleton?='singleton'? name=ID
	'implements' interfaces+=[Interface|QualifiedName] (',' interfaces+=[Interface|QualifiedName])*
	('namefr' namefr=STRING)? ('categories' categories+=[UserCategory|QualifiedName] (',' categories+=[UserCategory|QualifiedName])* )?
	classSetUp?='class-set-up'? testSetUp?='test-set-up'? classTearDown?='class-tear-down'? testTearDown?='test-tear-down'?
	'{'
		properties+=Pty*
		overrideFuncs+=OverrideFunction*
		functions+=Function*
		unitTestFunctions+=UnitTestFunction*
	'}';

OverrideFunction:
	description=Comment?
	'override' func=[Function|QualifiedName]
	 ('in' inVars+=VarReference (',' inVars+=VarReference)*)?
	 ('out' outVars+=VarReference (',' outVars+=VarReference)*)?
	 ('inout' inOutVars+=VarReference (',' inOutVars+=VarReference)*)?
	 ('call' calls+=[Function|QualifiedName] (',' calls+=[Function|QualifiedName])* )? ';';

UnitTestFunction:
	description=Comment?
	'test' name=ID 'label' label=STRING ';';

enum ServiceType:
	caseoption | application | session | subdomain;

// ----------------------------------------------------------------------------------------------------------------- //

Module:
	description=Comment?
	'module' name=ID ('implements' interfaces+=[Interface|QualifiedName] (',' interfaces+=[Interface|QualifiedName])*)?
	('namefr' namefr=STRING)? ('categories' categories+=[UserCategory|QualifiedName] (',' categories+=[UserCategory|QualifiedName])* )?
	'{'
		properties+=Pty*
		overrideFuncs+=OverrideFunction*
		functions+=Function*
		entryPoints+=EntryPoint*
	'}';

EntryPoint:
	description=Comment?
	('[' autoLoad=EntryPointAutoLoad ']')? 
	location=EntryPointLocation name=ID  
	('on' support=FunctionItem)? (sequential?='sequential')?
	('in' inVars+=VarReference (',' inVars+=VarReference)*)?
	('out' outVars+=VarReference (',' outVars+=VarReference)*)?
	('inout' inOutVars+=VarReference (',' inOutVars+=VarReference)*)?
	('call' calls+=[Function|QualifiedName] (',' calls+=[Function|QualifiedName])* )? ';';

enum EntryPointLocation:
	ComputeLoop='@ComputeLoop' | OnMeshChanged='@OnMeshChanged' | OnMeshRefinement='@OnMeshRefinement' | Init='@Init' | ContinueInit='@ContinueInit' | StartInit='@StartInit' | Restore='@Restore' | Build='@Build' | Exit='@Exit';

enum EntryPointAutoLoad:
	NoAutoLoad | AutoLoadBegin | AutoLoadEnd;

UserCategory:
	description=Comment?
	'UserCategory' name=ID ';';

Comment:
	comment=DOX_COMMENT;

// ----------------------------------------------------------------------------------------------------------------- //

Simple:
	type=SimpleType;

Item:
	type=ItemType;

FunctionItem:
	type=FunctionItemType;

ItemGroup:
	type=ItemGroupType;

Reference:
	target=[Referenceable|QualifiedName];

enum SimpleType:
	Boolean='bool' | ArrayBoolean='bool[*]' | Array2Boolean='bool[*,*]' |
	String='string'| ArrayString='string[*]' |
	Integer='int' | ArrayInteger='int[*]' | Array2Integer='int[*,*]' |
	Int32='int32' | ArrayInt32='int32[*]' | Array2Int32='int32[*,*]' |
	Int64='int64' | ArrayInt64='int64[*]' | Array2Int64='int64[*,*]' |
	Real='real' | ArrayReal='real[*]' | Array2Real='real[*,*]' |
	Real2='real[2]' | ArrayReal2='real[*,2]' | Array2Real2='real[*,*,2]' |
	Real2x2='real[2,2]' | ArrayReal2x2='real[*,2,2]' | Array2Real2x2='real[*,*,2,2]' |
	Real3='real[3]' | ArrayReal3='real[*,3]' | Array2Real3='real[*,*,3]' |
	Real3x3='real[3,3]' | ArrayReal3x3='real[*,3,3]' | Array2Real3x3='real[*,*,3,3]';

enum ItemType:
	Item='item' | Cell='cell' | Node='node' | Face='face' | Particle='particle' | MatCell='matCell' | EnvCell='envCell' | ComponentCell='componentCell' |
	AllEnvCell='allEnvCell' | DoF='DoF';

enum FunctionItemType:
	Item='item' | Cell='cell' | Node='node' | Face='face' | Particle='particle' | MatCell='matCell' | EnvCell='envCell' | ComponentCell='componentCell' |
	AllEnvCell='allEnvCell' | DoF='DoF' | ItemTypeSpecialized='itemTypeSpecialized';

enum ItemGroupType:
	NoItemGroup='noItemGroup' | ItemGroup='itemGroup' | CellGroup='cellGroup' | NodeGroup='nodeGroup' | FaceGroup='faceGroup' | ParticleGroup='particleGroup' |
	MatCellGroup='matCellGroup' | EnvCellGroup='envCellGroup' | ComponentCellGroup='componentCellGroup' | AllEnvCellGroup='allEnvCellGroup';

enum ReservedKeywords:
	Cells='cells' | Nodes='nodes' | Faces='faces' | Sum='sum' | Legacy='legacy';

enum Direction:
	in | out | inout;

enum PtyMultiplicity:
	ZeroOne='[0..1]' | OneOne='[1..1]' | ZeroStar='[0..*]' | OneStar='[1..*]';

terminal DUMP:
	'@dump';

terminal RESTORE:
	'@rest';

terminal EXEC_DEP:
	'@execdep';

terminal SYNC:
	'@sync';

// ----------------------------------------------------------------------------------------------------------------- //

@Override
terminal ML_COMMENT : '/*'(!'!') -> '*/';

terminal DOX_COMMENT : '/*!' -> '*/';

// ----------------------------------------------------------------------------------------------------------------- //
