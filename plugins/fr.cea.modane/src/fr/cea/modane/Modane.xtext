/*******************************************************************************
 * Copyright (c) 2022 CEA
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 * Contributors: see AUTHORS file
 *******************************************************************************/
grammar fr.cea.modane.Modane with org.eclipse.xtext.common.Terminals

generate modane "http://www.cea.fr/modane/Modane"

// ----------------------------------------------------------------------------------------------------------------- //

ModaneModel:
	description=Comment?
	'Model' name=QualifiedName ';'
	elements += ModaneElement*;

NamedElement:
	ModaneElement | Pty | EntryPoint | Function | UnitTestFunction | Arg | EnumerationLiteral;

Referenceable:
	Struct | Interface | Enumeration | Legacy;

ModaneElement:
	Variable | ServiceOrModule | Referenceable | ItemFamily | UserCategory;

QualifiedName:
	ID ('.' ID)*;

// ----------------------------------------------------------------------------------------------------------------- //

Variable:
	description=Comment?
	'var' type=SimpleType (multiplicity=VariableMultiplicity)? name=ID '{' (supports+=Item (',' supports+=Item)?)? '}'
	dump?=DUMP? restore?=RESTORE? executionDepend?=EXEC_DEP? needSync?=SYNC?
	('family' family=[ItemFamily|QualifiedName])? ';';

// ----------------------------------------------------------------------------------------------------------------- //

Enumeration:
	description=Comment?
	'enum' name=ID '{' literals+=EnumerationLiteral* '}';

EnumerationLiteral:
	description=Comment?
	('namefr' namefr=STRING)? ('categories' categories+=[UserCategory|QualifiedName] (',' categories+=[UserCategory|QualifiedName])* )?
	name=ID (valueProvided?='=' value=INT)?';';

// ----------------------------------------------------------------------------------------------------------------- //

Legacy:
	description=Comment?
	'legacy' name=ID 'file' originFile=STRING ('namespace' originNamespace=STRING)?;

// ----------------------------------------------------------------------------------------------------------------- //

Struct:
	description=Comment?
	'struct' name=ID ('extends' parents+=[Struct|QualifiedName] (',' parents+=[Struct|QualifiedName])* )?
	'{' 
		properties+=Pty* 
	'}';

Pty:
	description=Comment?
	multiplicity=PtyMultiplicity type=PtyOrArgType name=ID ('=' defaultValue=STRING)?
	('namefr' namefr=STRING)? ('categories' categories+=[UserCategory|QualifiedName] (',' categories+=[UserCategory|QualifiedName])* )? ';';

PtyOrArgType:
	Simple | Item | ItemGroup | Reference;

// ----------------------------------------------------------------------------------------------------------------- //

Interface:
	description=Comment?
	'interface' name=ID ('extends' parents+=[Interface|QualifiedName] (',' parents+=[Interface|QualifiedName])* )?
	'{'
		properties+=Pty*
		functions+=Function*
	'}';

Function:
	description=Comment?
	'def' const?='const'?
	('void'|(type=PtyOrArgType (multiple?='*')?))  name=ID
	'(' (args+=Arg (',' args+=Arg)*)? ')'
	 ('on' support=FunctionItem sequential?='sequentially'? )?
	 ('in' inVars+=VarReference (',' inVars+=VarReference)*)?
	 ('out' outVars+=VarReference (',' outVars+=VarReference)*)?
	 ('inout' inOutVars+=VarReference (',' inOutVars+=VarReference)*)?
	 ('call' calls+=[Function|QualifiedName] (',' calls+=[Function|QualifiedName])* )? ';';

Arg:
	ArgDefinition | VarDefinition;

ArgDefinition:
	direction=Direction type=PtyOrArgType (multiple?='*')? name=ID ('=' defaultValue=STRING)?;

VarDefinition:
	direction=Direction type=SimpleType (multiplicity=VariableMultiplicity)? name=ID '{' (supports+=Item (',' supports+=Item)?)? '}';

VarReference:
	variable=[Variable|QualifiedName];

// ----------------------------------------------------------------------------------------------------------------- //

ItemFamily:
	description=Comment?
	'ItemFamily' name=ID
	'on' support=ItemType ';';

// ----------------------------------------------------------------------------------------------------------------- //

ServiceOrModule:
	Service | Module;

Service:
	description=Comment?
	'service' type=ServiceType singleton?='singleton'? name=ID
	'implements' interfaces+=[Interface|QualifiedName] (',' interfaces+=[Interface|QualifiedName])*
	('namefr' namefr=STRING)? ('categories' categories+=[UserCategory|QualifiedName] (',' categories+=[UserCategory|QualifiedName])* )?
	classSetUp?='class-set-up'? testSetUp?='test-set-up'? classTearDown?='class-tear-down'? testTearDown?='test-tear-down'?
	'{'
		properties+=Pty*
		overrideFuncs+=OverrideFunction*
		functions+=Function*
		unitTestFunctions+=UnitTestFunction*
	'}';

OverrideFunction:
	description=Comment?
	'override' func=[Function|QualifiedName]
	 ('in' inVars+=VarReference (',' inVars+=VarReference)*)?
	 ('out' outVars+=VarReference (',' outVars+=VarReference)*)?
	 ('inout' inOutVars+=VarReference (',' inOutVars+=VarReference)*)?
	 ('call' calls+=[Function|QualifiedName] (',' calls+=[Function|QualifiedName])* )? ';';

UnitTestFunction:
	description=Comment?
	'test' name=ID 'label' label=STRING ';';

enum ServiceType:
	caseoption | application | session | subdomain;

// ----------------------------------------------------------------------------------------------------------------- //

Module:
	description=Comment?
	'module' name=ID ('implements' interfaces+=[Interface|QualifiedName] (',' interfaces+=[Interface|QualifiedName])*)?
	('namefr' namefr=STRING)? ('categories' categories+=[UserCategory|QualifiedName] (',' categories+=[UserCategory|QualifiedName])* )?
	'{'
		properties+=Pty*
		overrideFuncs+=OverrideFunction*
		functions+=Function*
		entryPoints+=EntryPoint*
	'}';

EntryPoint:
	description=Comment?
	('[' autoLoad=EntryPointAutoLoad ']')? 
	'@' location=EntryPointLocation name=ID  
	('on' support=FunctionItem sequential?='sequentially'? )?
	('in' inVars+=VarReference (',' inVars+=VarReference)*)?
	('out' outVars+=VarReference (',' outVars+=VarReference)*)?
	('inout' inOutVars+=VarReference (',' inOutVars+=VarReference)*)?
	('call' calls+=[Function|QualifiedName] (',' calls+=[Function|QualifiedName])* )? ';';

enum EntryPointLocation:
	ComputeLoop | OnMeshChanged | OnMeshRefinement | Init | ContinueInit | StartInit | Restore | Build | Exit;

enum EntryPointAutoLoad:
	NoAutoLoad | AutoLoadBegin | AutoLoadEnd;

UserCategory:
	description=Comment?
	'UserCategory' name=ID ';';

Comment:
	comment=DOX_COMMENT;

// ----------------------------------------------------------------------------------------------------------------- //

Simple:
	type=SimpleType;

Item:
	type=ItemType;

FunctionItem:
	type=FunctionItemType;

ItemGroup:
	type=ItemGroupType;

VariableMultiplicity:
	type=VariableMultiplicityType;

Reference:
	target=[Referenceable|QualifiedName];

enum SimpleType: 
	bool='bool' | String='string'| Integer='integer' | Int32='int32' | Int64='int64' | Real='real' |
	Real2='real[2]' | Real2x2='real[2,2]' | Real3='real[3]' | Real3x3='real[3,3]';

enum ItemType:
	Item='item' | Cell='cell' | Node='node' | Face='face' | Particle='particle' | MatCell='matCell' | EnvCell='envCell' | ComponentCell='componentCell' |
	AllEnvCell='allEnvCell' | DoF='DoF';

enum FunctionItemType:
	Item='item' | Cell='cell' | Node='node' | Face='face' | Particle='particle' | MatCell='matCell' | EnvCell='envCell' | ComponentCell='componentCell' |
	AllEnvCell='allEnvCell' | DoF='DoF' | ItemTypeSpecialized='itemTypeSpecialized';

enum ItemGroupType:
	NoItemGroup='noItemGroup' | ItemGroup='itemGroup' | CellGroup='cellGroup' | NodeGroup='nodeGroup' | FaceGroup='faceGroup' | ParticleGroup='particleGroup' |
	MatCellGroup='matCellGroup' | EnvCellGroup='envCellGroup' | ComponentCellGroup='componentCellGroup' | AllEnvCellGroup='allEnvCellGroup';

enum Direction:
	in | out | inout;

enum PtyMultiplicity:
	ZeroOne='[0..1]' | OneOne='[1..1]' | ZeroStar='[0..*]' | OneStar='[1..*]';

enum VariableMultiplicityType:
	array | array2;

terminal DUMP:
	'@dump';

terminal RESTORE:
	'@rest';

terminal EXEC_DEP:
	'@execDep';

terminal SYNC:
	'@sync';

// ----------------------------------------------------------------------------------------------------------------- //

@Override
terminal ML_COMMENT : '/*'(!'!') -> '*/';

terminal DOX_COMMENT : '/*!' -> '*/';

// ----------------------------------------------------------------------------------------------------------------- //
